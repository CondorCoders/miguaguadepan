---
// KonvaCanvas.astro - Componente para el canvas de Konva (REFACTORIZADO)
---

<div id="konva-container" class="konva-container">
  <div id="konva-stage"></div>
</div>

<script>
  // Importar Konva dinámicamente
  let Konva: any;

  // Configuración centralizada del canvas
  const CANVAS_CONFIG = {
    mobile: {
      width: 280,
      height: 400,
      baseSizes: { hat: 100, face: 70, outfit: 150 },
      baseScale: 0.65, // Tamaño de la imagen base
    },
    desktop: {
      width: 400,
      height: 630,
      baseSizes: { hat: 220, face: 120, outfit: 260 },
      baseScale: 0.7, // Tamaño de la imagen base
    },
    breakpoint: 600,
    scaleConstraints: { min: 0.2, max: 4 },
  };

  // Posiciones iniciales centralizadas
  const INITIAL_POSITIONS = {
    mobile: {
      hat: { x: 140, y: 85 },
      face: { x: 140, y: 150 },
      outfit: { x: 140, y: 255 },
    },
    desktop: {
      hat: { x: 200, y: 150 },
      face: { x: 200, y: 240 },
      outfit: { x: 200, y: 400 },
    },
  };

  class GuaguaCanvas {
    private stage: any;
    private layer: any;
    private baseImage: any = null;
    private transformer: any = null;
    private deleteButton: any = null;
    private isMobile: boolean = false;
    private needsRedraw: boolean = false;
    private pendingVersions: Record<string, number> = {
      hat: 0,
      face: 0,
      outfit: 0,
    };
    private eventHandler: any = null;
    private eventTypes: string[] = [
      "addHat",
      "addFace",
      "addOutfit",
      "clearElement",
      "deleteSelected",
      "downloadImage",
    ];

    constructor(containerId: string) {
      const container = document.getElementById(containerId);
      if (!container) {
        throw new Error(`Container with id "${containerId}" not found`);
      }

      this.isMobile = window.innerWidth < CANVAS_CONFIG.breakpoint;
      const config = this.getConfig();

      this.stage = new Konva.Stage({
        container: container as HTMLDivElement,
        width: config.width,
        height: config.height,
      });

      this.layer = new Konva.Layer();
      this.stage.add(this.layer);

      // Listener global de deselección
      this.stage.on("click tap", (e: any) => {
        if (e.target === this.stage) {
          this.clearSelection();
        }
      });

      this.loadBaseImage();
      this.setupEventListeners();
    }

    // MÉTODOS AUXILIARES CENTRALIZADOS

    private getConfig() {
      return this.isMobile ? CANVAS_CONFIG.mobile : CANVAS_CONFIG.desktop;
    }

    private getPositions() {
      return this.isMobile
        ? INITIAL_POSITIONS.mobile
        : INITIAL_POSITIONS.desktop;
    }

    private setCursor(cursor: string) {
      this.stage.container().style.cursor = cursor;
    }

    private clearSelection() {
      this.removeTransformer();
      this.removeDeleteButton();
    }

    private scheduleRedraw() {
      if (!this.needsRedraw) {
        this.needsRedraw = true;
        requestAnimationFrame(() => {
          this.layer.draw();
          this.needsRedraw = false;
        });
      }
    }

    private constrainScale(scale: number): number {
      const { min, max } = CANVAS_CONFIG.scaleConstraints;
      return Math.min(max, Math.max(min, scale));
    }

    private calculateProportionalDimensions(
      imageObj: HTMLImageElement,
      baseWidth: number,
      initialScale: number = 1
    ) {
      const aspectRatio = imageObj.naturalHeight / imageObj.naturalWidth;
      const finalWidth = baseWidth * initialScale;
      const finalHeight = finalWidth * aspectRatio;
      return { width: finalWidth, height: finalHeight };
    }

    private centerImage(
      konvaImage: any,
      width: number,
      height: number,
      position: { x: number; y: number }
    ) {
      konvaImage.x(position.x - width / 2);
      konvaImage.y(position.y - height / 2);
    }

    private bringToTop(node: any) {
      if (node && typeof node.moveToTop === "function") {
        node.moveToTop();
      }
    }

    private setupClickableCursor(target: any, hoverCursor: string = "pointer") {
      target.on("mouseenter", () => this.setCursor(hoverCursor));
      target.on("mouseleave", () => this.setCursor("default"));
    }

    public getViewportDimensions() {
      return {
        vh: Math.max(
          document.documentElement.clientHeight || 0,
          window.innerHeight || 0
        ),
        vw: Math.max(
          document.documentElement.clientWidth || 0,
          window.innerWidth || 0
        ),
      };
    }

    // IMAGEN BASE

    private async loadBaseImage() {
      const imageObj = new Image();
      imageObj.crossOrigin = "anonymous";

      return new Promise<void>((resolve) => {
        imageObj.onload = () => {
          const stageWidth = this.stage.width();
          const stageHeight = this.stage.height();
          const scale = this.getConfig().baseScale;

          // Calcular dimensiones manteniendo aspecto
          const naturalAspect = imageObj.naturalWidth / imageObj.naturalHeight;
          let imgWidth = stageWidth * scale;
          let imgHeight = stageHeight * scale;

          if (imgWidth / imgHeight > naturalAspect) {
            imgWidth = imgHeight * naturalAspect;
          } else {
            imgHeight = imgWidth / naturalAspect;
          }

          this.baseImage = new Konva.Image({
            x: (stageWidth - imgWidth) / 2,
            y: (stageHeight - imgHeight) / 2,
            image: imageObj,
            width: imgWidth,
            height: imgHeight,
            listening: false,
          });
          this.layer.add(this.baseImage);
          this.scheduleRedraw();
          resolve();
        };
        imageObj.src = "/guagua/base.png";
      });
    }

    // IMAGEN DRAGGABLE

    private setupImageEventHandlers(konvaImage: any) {
      // Click/Tap: seleccionar
      konvaImage.on("click tap", (e: any) => {
        e.cancelBubble = true;
        this.addTransformer(konvaImage);
        this.attachDeleteButton(konvaImage);
      });

      // Transform: limitar escala y actualizar botón de borrar
      konvaImage.on("transform", () => {
        const scale = this.constrainScale(konvaImage.scaleX());
        konvaImage.scale({ x: scale, y: scale });
        if (this.deleteButton) this.updateDeleteButtonPosition(konvaImage);
      });

      konvaImage.on("transformend", () => {
        const scale = this.constrainScale(konvaImage.scaleX());
        konvaImage.scale({ x: scale, y: scale });
        this.scheduleRedraw();
      });

      // Drag: actualizar botón de borrar
      konvaImage.on("dragmove", () => {
        if (this.deleteButton) this.updateDeleteButtonPosition(konvaImage);
      });

      // Drag Start: asegurar que el elemento esté seleccionado al empezar a arrastrar
      konvaImage.on("dragstart", () => {
        this.addTransformer(konvaImage);
        this.attachDeleteButton(konvaImage);
      });

      // Cursores de arrastre
      konvaImage.on("mouseenter", () => this.setCursor("grab"));
      konvaImage.on("mousedown touchstart", () => this.setCursor("grabbing"));
      konvaImage.on("dragend mouseup touchend", () => this.setCursor("grab"));
      konvaImage.on("mouseleave", () => {
        this.setCursor("default");
      });
    }

    private createDraggableImage(
      src: string,
      id: string,
      initialPosition: { x: number; y: number },
      initialScale: number = 1,
      version?: number
    ): any {
      const imageObj = new Image();
      imageObj.crossOrigin = "anonymous";

      const konvaImage = new Konva.Image({
        x: initialPosition.x,
        y: initialPosition.y,
        image: imageObj,
        draggable: true,
        id: id,
      });

      // Configurar event handlers
      this.setupImageEventHandlers(konvaImage);

      // Cargar imagen
      imageObj.onload = () => {
        // Verificar versión
        if (
          typeof version === "number" &&
          this.pendingVersions[id] !== version
        ) {
          return;
        }

        const baseSizes = this.getConfig().baseSizes;
        const baseWidth =
          baseSizes[id as keyof typeof baseSizes] ||
          (this.isMobile ? 100 : 120);

        // Calcular dimensiones
        const { width, height } = this.calculateProportionalDimensions(
          imageObj,
          baseWidth,
          initialScale
        );

        // Aplicar dimensiones y centrar
        konvaImage.width(width);
        konvaImage.height(height);
        this.centerImage(konvaImage, width, height, initialPosition);

        this.layer.add(konvaImage);
        this.scheduleRedraw();
      };
      imageObj.src = src;

      return konvaImage;
    }

    // EVENT LISTENERS

    private setupEventListeners() {
      const eventHandler = (event: any) => {
        switch (event.type) {
          case "addHat":
            this.addElement("hat", event.detail.src);
            break;
          case "addFace":
            this.addElement("face", event.detail.src);
            break;
          case "addOutfit":
            this.addElement("outfit", event.detail.src);
            break;
          case "clearElement":
            this.removeElement(event.detail.type);
            break;
          case "deleteSelected":
            this.deleteSelected();
            break;
          case "downloadImage":
            this.downloadImage();
            break;
        }
      };

      this.eventHandler = eventHandler;
      this.eventTypes.forEach((eventType) => {
        window.addEventListener(eventType, eventHandler);
      });
    }

    public destroy() {
      if (this.eventHandler) {
        this.eventTypes.forEach((eventType) => {
          window.removeEventListener(eventType, this.eventHandler);
        });
      }
    }

    // AÑADIR ELEMENTOS

    private addElement(type: "hat" | "face" | "outfit", src: string) {
      this.pendingVersions[type] += 1;
      const version = this.pendingVersions[type];
      this.removeElement(type);
      this.createDraggableImage(
        src,
        type,
        this.getPositions()[type],
        1.0,
        version
      );
    }

    // ELIMINAR ELEMENTOS

    public removeElement(type: string) {
      const elements = this.layer.find(`#${type}`);
      elements.forEach((element: any) => element.destroy());

      if (elements.length > 0) {
        this.clearSelection();
        this.scheduleRedraw();
      }
    }

    public deleteSelected() {
      if (this.transformer) {
        const nodes = this.transformer.nodes();
        nodes.forEach((node: any) => node.destroy());
        this.clearSelection();
        this.setCursor("default");
        this.scheduleRedraw();
      }
    }

    public async downloadImage() {
      this.removeTransformer();
      this.removeDeleteButton();
      // add background frame
      let backgroundNode: any | null = null;

      await new Promise<void>((resolve) => {
        const img = new Image();
        img.crossOrigin = "anonymous";

        img.onload = () => {
          const stageWidth = this.stage.width();
          const stageHeight = this.stage.height();

          // Calcular dimensiones manteniendo aspecto del marco
          const naturalAspect = img.naturalWidth / img.naturalHeight;
          const stageAspect = stageWidth / stageHeight;

          let bgWidth = stageWidth;
          let bgHeight = stageHeight;
          let bgX = 0;
          let bgY = 0;

          // Ajustar para cubrir todo el stage sin deformar
          if (stageAspect > naturalAspect) {
            // Stage más ancho que el marco
            bgHeight = stageWidth / naturalAspect;
            bgY = (stageHeight - bgHeight) / 2;
          } else {
            // Stage más alto que el marco
            bgWidth = stageHeight * naturalAspect;
            bgX = (stageWidth - bgWidth) / 2;
          }

          backgroundNode = new Konva.Image({
            x: bgX,
            y: bgY,
            image: img,
            width: bgWidth,
            height: bgHeight,
            listening: false,
          });

          this.layer.add(backgroundNode);
          backgroundNode.moveToBottom(); // Poner el fondo debajo del muñeco y atuendos
          this.layer.draw();
          resolve();
        };
        img.src = "/guagua/marco.jpg";
      });

      // add logo
      let logoNode: any | null = null;

      await new Promise<void>((resolve) => {
        const img = new Image();
        img.crossOrigin = "anonymous";

        img.onload = () => {
          const desiredWidth = 100;
          const aspect = img.naturalHeight / img.naturalWidth || 1;
          const desiredHeight = desiredWidth * aspect;
          const margin = this.isMobile ? 6 : 10;

          const x = margin; // Esquina superior izquierda
          const y = margin - 10; // Más arriba

          logoNode = new Konva.Image({
            x,
            y,
            image: img,
            width: desiredWidth,
            height: desiredHeight,
            listening: false,
          });

          this.layer.add(logoNode);
          logoNode.moveToTop(); // Poner el logo encima de todo
          this.layer.draw();
          resolve();
        };
        img.src = "/logo.png";
      });

      const dataURL = this.stage.toDataURL({ pixelRatio: 3 });

      if (backgroundNode) {
        backgroundNode.destroy();
      }
      if (logoNode) {
        logoNode.destroy();
      }
      this.layer.draw();
      const link = document.createElement("a");
      link.href = dataURL;
      link.download = "mi-guagua-de-pan.png";
      link.click();
    }

    // TRANSFORMER

    private addTransformer(node: any) {
      if (!this.transformer) {
        this.transformer = new Konva.Transformer({
          rotateEnabled: true,
          rotateAnchorOffset: 25,
          enabledAnchors: [
            "top-left",
            "top-right",
            "bottom-left",
            "bottom-right",
          ],
          padding: 8,
        });
        this.layer.add(this.transformer);
      }
      this.transformer.nodes([node]);
      this.bringToTop(this.transformer);
      this.scheduleRedraw();
    }

    private removeTransformer() {
      if (this.transformer) {
        this.transformer.nodes([]);
        this.scheduleRedraw();
      }
    }

    // BOTÓN DE BORRAR

    private attachDeleteButton(node: any) {
      this.removeDeleteButton();

      const group = new Konva.Group({ listening: true, name: "delete-button" });
      const circle = new Konva.Circle({
        radius: 12,
        fill: "#ef4444",
        stroke: "#ffffff",
        strokeWidth: 2,
        shadowColor: "black",
        shadowBlur: 4,
        shadowOpacity: 0.2,
      });
      const text = new Konva.Text({
        text: "x",
        fontSize: 18,
        fontStyle: "bold",
        fill: "#ffffff",
        offsetX: 5,
        offsetY: 10,
      });
      group.add(circle);
      group.add(text);

      this.layer.add(group);
      this.updateDeleteButtonPosition(node, group);

      group.on("click tap", (e: any) => {
        e.cancelBubble = true;
        node.destroy();
        this.clearSelection();
        this.setCursor("default");
        this.scheduleRedraw();
      });

      this.setupClickableCursor(group, "pointer");
      this.bringToTop(group);
      this.deleteButton = group;
      this.scheduleRedraw();
    }

    private updateDeleteButtonPosition(node: any, button?: any) {
      const target = button || this.deleteButton;
      if (!target) return;

      const abs = node.getAbsoluteTransform();
      const w = node.width();
      const h = node.height();
      const topRight = abs.point({ x: w, y: 0 });
      const center = abs.point({ x: w / 2, y: h / 2 });

      const dx = topRight.x - center.x;
      const dy = topRight.y - center.y;
      const len = Math.max(1, Math.hypot(dx, dy));
      const offset = 8;
      const px = topRight.x + (dx / len) * offset;
      const py = topRight.y + (dy / len) * offset;

      target.position({ x: px, y: py });
      this.bringToTop(target);
      this.scheduleRedraw();
    }

    private removeDeleteButton() {
      if (this.deleteButton) {
        this.deleteButton.destroy();
        this.deleteButton = null;
        this.scheduleRedraw();
      }
    }

    // RESIZE

    public resize(width: number, height: number) {
      this.stage.width(width);
      this.stage.height(height);
      this.scheduleRedraw();
    }
  }

  // RESPONSIVE

  const updateResponsiveCanvasSize = (canvas: any) => {
    const container = document.getElementById("konva-container");
    if (!container) return;

    const isMobile = window.innerWidth < CANVAS_CONFIG.breakpoint;
    const config = isMobile ? CANVAS_CONFIG.mobile : CANVAS_CONFIG.desktop;

    const { vh, vw } = (
      window as any
    ).guaguaCanvas?.getViewportDimensions() || {
      vh: Math.max(
        document.documentElement.clientHeight || 0,
        window.innerHeight || 0
      ),
      vw: Math.max(
        document.documentElement.clientWidth || 0,
        window.innerWidth || 0
      ),
    };

    const maxHeight = Math.floor(0.8 * vh);
    const maxWidth = Math.floor(0.98 * vw);

    const width = Math.min(container.offsetWidth || vw, config.width, maxWidth);
    const height = Math.min(config.height, maxHeight);

    canvas.resize(width, height);
  };

  // INICIALIZACIÓN

  document.addEventListener("DOMContentLoaded", async () => {
    try {
      const konvaModule = await import("konva");
      Konva = konvaModule.default;

      const canvas = new GuaguaCanvas("konva-stage");

      updateResponsiveCanvasSize(canvas);
      window.addEventListener("resize", () =>
        updateResponsiveCanvasSize(canvas)
      );

      (window as any).guaguaCanvas = canvas;
    } catch (error) {
      console.error("Error loading Konva:", error);
    }
  });
</script>

<style>
  .konva-container {
    display: flex;
    justify-content: center;
    align-items: center;
    width: auto;
    height: auto;
    max-width: 100vw;
    max-height: 80vh;
    margin: 0 auto;
    box-sizing: border-box;
    background-image: url(/guagua/marco.jpg);
    background-repeat: no-repeat;
    background-size: cover;
    background-position: center;
    border-radius: 1rem;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.671);
  }

  #konva-stage {
    display: block;
    margin: 0 auto;
    max-width: 100vw;
    max-height: 80vh;
    width: auto;
    height: auto;
  }
</style>
