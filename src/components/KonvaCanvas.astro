<div id="konva-container" class="konva-container">
  <div id="konva-stage"></div>
</div>

<script>
  // Importar Konva dinámicamente
  let Konva: any;

  // Configuración responsiva del canvas
  const RESPONSIVE_CONFIG = {
    // Anchura base de cada elemento relativa al ancho del canvas
    baseFactors: { hat: 0.45, face: 0.28, outfit: 0.6 },
    // Escala de la imagen base (muñeco) dentro del stage
    baseImageScale: 0.7,
    // Límites de escala para transformaciones
    scaleConstraints: { min: 0.2, max: 4 },
    // Relación de aspecto preferida del lienzo (ancho/alto). Corresponde aprox. al marco.
    aspectRatio: 400 / 630,
  } as const;

  class GuaguaCanvas {
    private stage: any;
    private layer: any;
    private contentGroup: any;
    private baseStageSize: { w: number; h: number } = {
      w: 400,
      h: Math.round(400 / RESPONSIVE_CONFIG.aspectRatio), // ~630
    };
    private baseImage: any = null;
    private transformer: any = null;
    private deleteButton: any = null;
    private needsRedraw: boolean = false;
    private pendingVersions: Record<string, number> = {
      hat: 0,
      face: 0,
      outfit: 0,
    };
    private eventHandler: any = null;
    private eventTypes: string[] = [
      "addHat",
      "addFace",
      "addOutfit",
      "clearElement",
      "deleteSelected",
      "downloadImage",
    ];

    constructor(containerId: string) {
      const container = document.getElementById(containerId);
      if (!container) {
        throw new Error(`Container with id "${containerId}" not found`);
      }

      // Fit inicial al tamaño disponible del contenedor padre
      const { width: initW, height: initH } = GuaguaCanvas.getContainerSize(
        container.parentElement as HTMLDivElement
      );

      this.stage = new Konva.Stage({
        container: container as HTMLDivElement,
        width: initW,
        height: initH,
      });

      this.layer = new Konva.Layer();
      this.stage.add(this.layer);

      // Guardar tamaño base de diseño sólo si hay medidas válidas; si no, usar fallback 400x630
      if (initW > 0 && initH > 0) {
        this.baseStageSize = { w: initW, h: initH };
      }
      // Grupo raíz cuyo contenido se escala/centra al redimensionar
      this.contentGroup = new Konva.Group({ name: "content-root" });
      this.layer.add(this.contentGroup);

      // Listener global de deselección
      this.stage.on("click tap", (e: any) => {
        if (e.target === this.stage) {
          this.clearSelection();
        }
      });

      this.loadBaseImage();
      this.setupEventListeners();
      // Ajustar escala y centrado inicial por si el contenedor cambia inmediatamente
      this.updateScaleAndPosition();
    }

    // MÉTODOS AUXILIARES
    static getContainerSize(container: HTMLDivElement) {
      if (!container) return { width: 0, height: 0 };
      const width = Math.round(container.clientWidth || 0);
      // Si el alto no está definido aún (0), deducirlo por la relación de aspecto preferida
      const height = Math.round(
        container.clientHeight && container.clientHeight > 0
          ? container.clientHeight
          : width / RESPONSIVE_CONFIG.aspectRatio
      );
      return { width, height };
    }

    private setCursor(cursor: string) {
      this.stage.container().style.cursor = cursor;
    }

    private clearSelection() {
      this.removeTransformer();
      this.removeDeleteButton();
    }

    private scheduleRedraw() {
      if (!this.needsRedraw) {
        this.needsRedraw = true;
        requestAnimationFrame(() => {
          this.layer.draw();
          this.needsRedraw = false;
        });
      }
    }

    private constrainScale(scale: number): number {
      const { min, max } = RESPONSIVE_CONFIG.scaleConstraints;
      return Math.min(max, Math.max(min, scale));
    }

    private calculateProportionalDimensions(
      imageObj: HTMLImageElement,
      baseWidth: number,
      initialScale: number = 1
    ) {
      const aspectRatio = imageObj.naturalHeight / imageObj.naturalWidth;
      const finalWidth = baseWidth * initialScale;
      const finalHeight = finalWidth * aspectRatio;
      return { width: finalWidth, height: finalHeight };
    }

    private centerImage(
      konvaImage: any,
      width: number,
      height: number,
      position: { x: number; y: number }
    ) {
      konvaImage.x(position.x - width / 2);
      konvaImage.y(position.y - height / 2);
    }

    private bringToTop(node: any) {
      if (node && typeof node.moveToTop === "function") {
        node.moveToTop();
      }
    }

    private setupClickableCursor(target: any, hoverCursor: string = "pointer") {
      target.on("mouseenter", () => this.setCursor(hoverCursor));
      target.on("mouseleave", () => this.setCursor("default"));
    }

    public getViewportDimensions() {
      return {
        vh: Math.max(
          document.documentElement.clientHeight || 0,
          window.innerHeight || 0
        ),
        vw: Math.max(
          document.documentElement.clientWidth || 0,
          window.innerWidth || 0
        ),
      };
    }

    // IMAGEN BASE
    private async loadBaseImage() {
      const imageObj = new Image();
      imageObj.crossOrigin = "anonymous";

      return new Promise<void>((resolve) => {
        imageObj.onload = () => {
          const stageWidth = this.baseStageSize.w;
          const stageHeight = this.baseStageSize.h;
          const scale = RESPONSIVE_CONFIG.baseImageScale;

          // Calcular dimensiones manteniendo aspecto
          const naturalAspect = imageObj.naturalWidth / imageObj.naturalHeight;
          let imgWidth = stageWidth * scale;
          let imgHeight = stageHeight * scale;

          if (imgWidth / imgHeight > naturalAspect) {
            imgWidth = imgHeight * naturalAspect;
          } else {
            imgHeight = imgWidth / naturalAspect;
          }

          this.baseImage = new Konva.Image({
            x: (stageWidth - imgWidth) / 2,
            y: (stageHeight - imgHeight) / 2,
            image: imageObj,
            width: imgWidth,
            height: imgHeight,
            listening: false,
          });
          this.contentGroup.add(this.baseImage);
          this.scheduleRedraw();
          resolve();
        };
        imageObj.src = "/guagua/base.png";
      });
    }

    // IMAGEN DRAGGABLE
    private setupImageEventHandlers(konvaImage: any) {
      // Click/Tap: seleccionar
      konvaImage.on("click tap", (e: any) => {
        e.cancelBubble = true;
        this.addTransformer(konvaImage);
        this.attachDeleteButton(konvaImage);
      });

      // Transform: limitar escala y actualizar botón de borrar
      konvaImage.on("transform", () => {
        const scale = this.constrainScale(konvaImage.scaleX());
        konvaImage.scale({ x: scale, y: scale });
        if (this.deleteButton) this.updateDeleteButtonPosition(konvaImage);
      });

      konvaImage.on("transformend", () => {
        const scale = this.constrainScale(konvaImage.scaleX());
        konvaImage.scale({ x: scale, y: scale });
        this.scheduleRedraw();
      });

      // Drag: actualizar botón de borrar
      konvaImage.on("dragmove", () => {
        if (this.deleteButton) this.updateDeleteButtonPosition(konvaImage);
      });

      // Drag Start: asegurar que el elemento esté seleccionado al empezar a arrastrar
      konvaImage.on("dragstart", () => {
        this.addTransformer(konvaImage);
        this.attachDeleteButton(konvaImage);
      });

      // Cursores de arrastre
      konvaImage.on("mouseenter", () => this.setCursor("grab"));
      konvaImage.on("mousedown touchstart", () => this.setCursor("grabbing"));
      konvaImage.on("dragend mouseup touchend", () => this.setCursor("grab"));
      konvaImage.on("mouseleave", () => {
        this.setCursor("default");
      });
    }

    private createDraggableImage(
      src: string,
      id: string,
      initialPosition: { x: number; y: number },
      initialScale: number = 1,
      version?: number
    ): any {
      const imageObj = new Image();
      imageObj.crossOrigin = "anonymous";

      const konvaImage = new Konva.Image({
        x: initialPosition.x,
        y: initialPosition.y,
        image: imageObj,
        draggable: true,
        id: id,
      });

      // Configurar event handlers
      this.setupImageEventHandlers(konvaImage);

      // Cargar imagen
      imageObj.onload = () => {
        // Verificar versión
        if (
          typeof version === "number" &&
          this.pendingVersions[id] !== version
        ) {
          return;
        }

        // Anchura base relativa al ancho del stage
        const factor =
          RESPONSIVE_CONFIG.baseFactors[
            id as keyof typeof RESPONSIVE_CONFIG.baseFactors
          ] || 0.4;
        const baseWidth = this.baseStageSize.w * factor;

        // Calcular dimensiones
        const { width, height } = this.calculateProportionalDimensions(
          imageObj,
          baseWidth,
          initialScale
        );

        // Aplicar dimensiones y centrar
        konvaImage.width(width);
        konvaImage.height(height);
        this.centerImage(konvaImage, width, height, initialPosition);

        this.contentGroup.add(konvaImage);
        this.scheduleRedraw();
      };
      imageObj.src = src;

      this.addTransformer(konvaImage);

      return konvaImage;
    }

    // EVENT LISTENERS
    private setupEventListeners() {
      const eventHandler = (event: any) => {
        switch (event.type) {
          case "addHat":
            this.addElement("hat", event.detail.src);
            break;
          case "addFace":
            this.addElement("face", event.detail.src);
            break;
          case "addOutfit":
            this.addElement("outfit", event.detail.src);
            break;
          case "clearElement":
            this.removeElement(event.detail.type);
            break;
          case "deleteSelected":
            this.deleteSelected();
            break;
          case "downloadImage":
            this.downloadImage();
            break;
        }
      };

      this.eventHandler = eventHandler;
      this.eventTypes.forEach((eventType) => {
        window.addEventListener(eventType, eventHandler);
      });
    }

    public destroy() {
      if (this.eventHandler) {
        this.eventTypes.forEach((eventType) => {
          window.removeEventListener(eventType, this.eventHandler);
        });
      }
    }

    // AÑADIR ELEMENTOS
    private addElement(type: "hat" | "face" | "outfit", src: string) {
      this.pendingVersions[type] += 1;
      const version = this.pendingVersions[type];
      this.removeElement(type);
      this.createDraggableImage(
        src,
        type,
        this.getInitialPosition(type),
        1.0,
        version
      );
    }

    private getInitialPosition(type: "hat" | "face" | "outfit") {
      const w = this.baseStageSize.w;
      const h = this.baseStageSize.h;
      const x = w / 2;
      const yMap: Record<typeof type, number> = {
        hat: 0.22 * h,
        face: 0.38 * h,
        outfit: 0.65 * h,
      } as const;
      return { x, y: yMap[type] };
    }

    // ELIMINAR ELEMENTOS
    public removeElement(type: string) {
      const elements = this.layer.find(`#${type}`);
      elements.forEach((element: any) => element.destroy());

      if (elements.length > 0) {
        this.clearSelection();
        this.scheduleRedraw();
      }
    }

    public deleteSelected() {
      if (this.transformer) {
        const nodes = this.transformer.nodes();
        nodes.forEach((node: any) => node.destroy());
        this.clearSelection();
        this.setCursor("default");
        this.scheduleRedraw();
      }
    }
    // DESCARGAR IMAGEN
    public async downloadImage() {
      this.removeTransformer();
      this.removeDeleteButton();
      // add background frame
      let backgroundNode: any | null = null;

      await new Promise<void>((resolve) => {
        const img = new Image();
        img.crossOrigin = "anonymous";

        img.onload = () => {
          const stageWidth = this.stage.width();
          const stageHeight = this.stage.height();

          // Calcular dimensiones manteniendo aspecto del marco
          const naturalAspect = img.naturalWidth / img.naturalHeight;
          const stageAspect = stageWidth / stageHeight;

          let bgWidth = stageWidth;
          let bgHeight = stageHeight;
          let bgX = 0;
          let bgY = 0;

          // Ajustar para cubrir todo el stage sin deformar
          if (stageAspect > naturalAspect) {
            // Stage más ancho que el marco
            bgHeight = stageWidth / naturalAspect;
            bgY = (stageHeight - bgHeight) / 2;
          } else {
            // Stage más alto que el marco
            bgWidth = stageHeight * naturalAspect;
            bgX = (stageWidth - bgWidth) / 2;
          }

          backgroundNode = new Konva.Image({
            x: bgX,
            y: bgY,
            image: img,
            width: bgWidth,
            height: bgHeight,
            listening: false,
          });

          this.layer.add(backgroundNode);
          backgroundNode.moveToBottom(); // Poner el fondo debajo del muñeco y atuendos
          this.layer.draw();
          resolve();
        };
        img.src = "/guagua/marco.jpg";
      });

      // add logo
      let logoNode: any | null = null;

      await new Promise<void>((resolve) => {
        const img = new Image();
        img.crossOrigin = "anonymous";

        img.onload = () => {
          const desiredWidth = 100;
          const aspect = img.naturalHeight / img.naturalWidth || 1;
          const desiredHeight = desiredWidth * aspect;
          const isSmall = this.stage.width() < 420;
          const margin = isSmall ? 6 : 10;

          const x = margin; // Esquina superior izquierda
          const y = margin - 10; // Más arriba

          logoNode = new Konva.Image({
            x,
            y,
            image: img,
            width: desiredWidth,
            height: desiredHeight,
            listening: false,
          });

          this.layer.add(logoNode);
          logoNode.moveToTop(); // Poner el logo encima de todo
          this.layer.draw();
          resolve();
        };
        img.src = "/logo.png";
      });

      // Renderizar a Blob y descargar con Object URL (mejor UX que data:)
      const canvasEl: HTMLCanvasElement = this.stage.toCanvas({
        pixelRatio: 3,
      });
      const blob: Blob = await new Promise((resolve, reject) => {
        canvasEl.toBlob(
          (b) =>
            b ? resolve(b) : reject(new Error("No se pudo crear el Blob")),
          "image/png"
        );
      });

      if (backgroundNode) {
        backgroundNode.destroy();
      }
      if (logoNode) {
        logoNode.destroy();
      }
      this.layer.draw();

      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "mi-guagua-de-pan.png";
      document.body.appendChild(link);
      link.click();
      link.remove();
      // Revocar después del click para liberar memoria
      setTimeout(() => URL.revokeObjectURL(url), 0);
    }

    // TRANSFORMER
    private addTransformer(node: any) {
      if (!this.transformer) {
        this.transformer = new Konva.Transformer({
          rotateEnabled: true,
          rotateAnchorOffset: 25,
          enabledAnchors: [
            "top-left",
            "top-right",
            "bottom-left",
            "bottom-right",
          ],
          padding: 8,
        });
        this.layer.add(this.transformer);
      }
      this.transformer.nodes([node]);
      this.bringToTop(this.transformer);
      this.scheduleRedraw();
    }

    private removeTransformer() {
      if (this.transformer) {
        this.transformer.nodes([]);
        this.scheduleRedraw();
      }
    }

    // BOTÓN DE BORRAR
    private attachDeleteButton(node: any) {
      this.removeDeleteButton();

      const group = new Konva.Group({ listening: true, name: "delete-button" });
      const circle = new Konva.Circle({
        radius: 12,
        fill: "#ef4444",
        stroke: "#ffffff",
        strokeWidth: 2,
        shadowColor: "black",
        shadowBlur: 4,
        shadowOpacity: 0.2,
      });
      const text = new Konva.Text({
        text: "x",
        fontSize: 18,
        fontStyle: "bold",
        fill: "#ffffff",
        offsetX: 5,
        offsetY: 10,
      });
      group.add(circle);
      group.add(text);

      this.layer.add(group);
      this.updateDeleteButtonPosition(node, group);

      group.on("click tap", (e: any) => {
        e.cancelBubble = true;
        node.destroy();
        this.clearSelection();
        this.setCursor("default");
        this.scheduleRedraw();
      });

      this.setupClickableCursor(group, "pointer");
      this.bringToTop(group);
      this.deleteButton = group;
      this.scheduleRedraw();
    }

    private updateDeleteButtonPosition(node: any, button?: any) {
      const target = button || this.deleteButton;
      if (!target) return;

      const abs = node.getAbsoluteTransform();
      const w = node.width();
      const h = node.height();
      const topRight = abs.point({ x: w, y: 0 });
      const center = abs.point({ x: w / 2, y: h / 2 });

      const dx = topRight.x - center.x;
      const dy = topRight.y - center.y;
      const len = Math.max(1, Math.hypot(dx, dy));
      const offset = 8;
      const px = topRight.x + (dx / len) * offset;
      const py = topRight.y + (dy / len) * offset;

      target.position({ x: px, y: py });
      this.bringToTop(target);
      this.scheduleRedraw();
    }

    private removeDeleteButton() {
      if (this.deleteButton) {
        this.deleteButton.destroy();
        this.deleteButton = null;
        this.scheduleRedraw();
      }
    }

    // RESIZE
    private updateScaleAndPosition() {
      const stageW = this.stage.width();
      const stageH = this.stage.height();
      const baseW = this.baseStageSize.w;
      const baseH = this.baseStageSize.h;
      if (baseW <= 0 || baseH <= 0) return;

      const scale = Math.min(stageW / baseW, stageH / baseH);
      this.contentGroup.scale({ x: scale, y: scale });
      const offX = (stageW - baseW * scale) / 2;
      const offY = (stageH - baseH * scale) / 2;
      this.contentGroup.position({ x: offX, y: offY });

      // Forzar actualización del transformer si existe
      if (
        this.transformer &&
        typeof this.transformer.forceUpdate === "function"
      ) {
        this.transformer.forceUpdate();
      }

      this.scheduleRedraw();
    }

    public resize(width: number, height: number) {
      if (!width || !height) return;
      this.stage.width(width);
      this.stage.height(height);
      // Si aún no tenemos tamaño base válido, inicializarlo ahora
      if (this.baseStageSize.w <= 0 || this.baseStageSize.h <= 0) {
        this.baseStageSize = { w: width, h: height };
      }
      this.updateScaleAndPosition();
    }
  }

  // RESPONSIVE
  const updateResponsiveCanvasSize = (canvas: any) => {
    const container = document.getElementById(
      "konva-container"
    ) as HTMLDivElement | null;
    if (!container) return;

    // Dimensionarse a partir del área real del canvas (sección #guagua en Editor.astro)
    const guagua = document.getElementById("guagua") as HTMLElement | null;
    const downloadBtn = document.getElementById(
      "download"
    ) as HTMLElement | null;

    const vw = Math.max(
      document.documentElement.clientWidth || 0,
      window.innerWidth || 0
    );
    const isWide = window.matchMedia("(min-width: 48rem)").matches;
    const gap = 16; // espacio vertical entre canvas y botón

    // Medir ancho disponible: usar el ancho efectivo del contenedor de canvas (columna de #guagua)
    const availableWidth = Math.max(
      0,
      guagua?.clientWidth ||
        container.parentElement?.clientWidth ||
        container.clientWidth ||
        Math.floor(0.9 * vw)
    );

    // Medir alto disponible: altura de #guagua menos la altura del botón y un gap
    const btnH = downloadBtn ? downloadBtn.offsetHeight : 0;
    const guaguaHeight =
      guagua?.clientHeight || container.parentElement?.clientHeight || 0;
    let availableHeight = Math.max(0, guaguaHeight - btnH - gap);
    // Fallback si aún no hay layout
    if (!availableHeight) {
      const vh = Math.max(
        document.documentElement.clientHeight || 0,
        window.innerHeight || 0
      );
      availableHeight = isWide ? Math.floor(0.85 * vh) : Math.floor(0.48 * vh);
    }

    // Ajustar tamaño del stage manteniendo aspecto y sin exceder el espacio disponible
    const aspect = RESPONSIVE_CONFIG.aspectRatio; // w/h
    const widthByHeight = Math.floor(availableHeight * aspect);
    const width = Math.min(availableWidth, widthByHeight);
    const height = Math.round(width / aspect);

    container.style.width = `${width}px`;
    container.style.height = `${height}px`;
    canvas.resize(width, height);
  };

  // INICIALIZACIÓN
  document.addEventListener("DOMContentLoaded", async () => {
    try {
      const konvaModule = await import("konva");
      Konva = konvaModule.default;

      const canvas = new GuaguaCanvas("konva-stage");

      // Ajuste inicial y observers para cambios de tamaño
      updateResponsiveCanvasSize(canvas);
      window.addEventListener("resize", () =>
        updateResponsiveCanvasSize(canvas)
      );

      const container = document.getElementById(
        "konva-container"
      ) as HTMLDivElement | null;
      const guagua = document.getElementById("guagua") as HTMLDivElement | null;
      if ("ResizeObserver" in window) {
        const ro = new ResizeObserver(() => updateResponsiveCanvasSize(canvas));
        if (container) ro.observe(container);
        if (guagua) ro.observe(guagua);
        (window as any).guaguaResizeObserver = ro;
      }

      (window as any).guaguaCanvas = canvas;
    } catch (error) {
      console.error("Error loading Konva:", error);
    }
  });
</script>

<style>
  .konva-container {
    display: flex;
    justify-content: center;
    align-items: center;
    width: auto;
    height: auto;
    aspect-ratio: 400 / 630; /* Mantener relación de aspecto del lienzo/marco */
    max-width: 100vw;
    max-height: 95dvh;
    margin: 0 auto;
    box-sizing: border-box;
    background-image: url(/guagua/marco.jpg);
    background-repeat: no-repeat;
    background-size: cover;
    background-position: center;
    border-radius: 1rem;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.671);
  }

  #konva-stage {
    display: block;
    margin: 0 auto;
    max-width: 100vw;
    max-height: 95dvh;
    width: auto;
    height: auto;
  }

  /* Mantener la altura acotada también en desktop para evitar scroll de página */
</style>
