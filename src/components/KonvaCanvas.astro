---
// KonvaCanvas.astro - Componente para el canvas de Konva
---

<div id="konva-container" class="konva-container">
  <div id="konva-stage"></div>
</div>

<script>
  // Importar Konva dinámicamente
  let Konva: any;

  class GuaguaCanvas {
    private stage: any;
    private layer: any;
    private baseImage: any = null;
    private transformer: any = null;
    private isMobile: boolean = false;
    private needsRedraw: boolean = false;
    private pendingVersions: Record<string, number> = {
      hat: 0,
      face: 0,
      outfit: 0,
    };
    private eventHandler: any = null;
    private eventTypes: string[] = [
      "addHat",
      "addFace",
      "addOutfit",
      "clearElement",
      "deleteSelected",
    ];

    constructor(containerId: string) {
      const container = document.getElementById(containerId);
      if (!container) {
        throw new Error(`Container with id "${containerId}" not found`);
      }

      // Cachear estado móvil
      this.isMobile = window.innerWidth < CANVAS_CONFIG.breakpoint;
      const config = this.isMobile
        ? CANVAS_CONFIG.mobile
        : CANVAS_CONFIG.desktop;

      this.stage = new Konva.Stage({
        container: container as HTMLDivElement,
        width: config.width,
        height: config.height,
      });

      // Crear layer
      this.layer = new Konva.Layer();
      this.stage.add(this.layer);

      // Listener global de deselección (registrar solo una vez)
      this.stage.on("click tap", (e: any) => {
        if (e.target === this.stage) this.removeTransformer();
      });

      // Cargar imagen base
      this.loadBaseImage();

      // Escuchar eventos de cambio de elementos
      this.setupEventListeners();
    }

    private async loadBaseImage() {
      const imageObj = new Image();
      imageObj.crossOrigin = "anonymous";

      return new Promise<void>((resolve) => {
        imageObj.onload = () => {
          const stageWidth = this.stage.width();
          const stageHeight = this.stage.height();
          const scale = this.isMobile ? 0.65 : 0.85;

          // Calcular dimensiones manteniendo aspecto
          const naturalAspect = imageObj.naturalWidth / imageObj.naturalHeight;
          let imgWidth = stageWidth * scale;
          let imgHeight = stageHeight * scale;

          if (imgWidth / imgHeight > naturalAspect) {
            imgWidth = imgHeight * naturalAspect;
          } else {
            imgHeight = imgWidth / naturalAspect;
          }

          this.baseImage = new Konva.Image({
            x: (stageWidth - imgWidth) / 2,
            y: (stageHeight - imgHeight) / 2,
            image: imageObj,
            width: imgWidth,
            height: imgHeight,
            listening: false,
          });
          this.layer.add(this.baseImage);
          this.scheduleRedraw();
          resolve();
        };
        imageObj.src = "/guagua/base.png";
      });
    }

    // Optimización: Redibujar solo cuando sea necesario
    private scheduleRedraw() {
      if (!this.needsRedraw) {
        this.needsRedraw = true;
        requestAnimationFrame(() => {
          this.layer.draw();
          this.needsRedraw = false;
        });
      }
    }

    private createDraggableImage(
      src: string,
      id: string,
      initialPosition: { x: number; y: number },
      initialScale: number = 1,
      version?: number
    ): any {
      const imageObj = new Image();
      imageObj.crossOrigin = "anonymous";

      const konvaImage = new Konva.Image({
        x: initialPosition.x,
        y: initialPosition.y,
        image: imageObj,
        draggable: true,
        id: id,
      });

      konvaImage.on("click tap", (e: any) => {
        e.cancelBubble = true;
        this.addTransformer(konvaImage);
        console.log(konvaImage);
      });
      konvaImage.on("transform", () => {
        // Limitar escala mínima y máxima visualmente (por si el usuario arrastra demasiado)
        const scale = konvaImage.scaleX();
        if (scale < 0.2) konvaImage.scale({ x: 0.2, y: 0.2 });
        if (scale > 4) konvaImage.scale({ x: 4, y: 4 });
      });
      konvaImage.on("transformend", () => {
        const s = Math.min(4, Math.max(0.2, konvaImage.scaleX()));
        konvaImage.scale({ x: s, y: s });
        this.scheduleRedraw();
      });

      // Cargar imagen
      imageObj.onload = () => {
        // Si llegó una solicitud más nueva para este grupo, descartar esta carga
        if (
          typeof version === "number" &&
          this.pendingVersions[id] !== version
        ) {
          return;
        }
        // Tamaños base por tipo de elemento (diferentes para móvil y desktop)
        const baseSizes = this.isMobile
          ? { hat: 100, face: 120, outfit: 150 } // Tamaños para móvil
          : { hat: 220, face: 120, outfit: 260 }; // Tamaños para desktop
        const baseWidth =
          baseSizes[id as keyof typeof baseSizes] ||
          (this.isMobile ? 100 : 120);

        // Calcular dimensiones proporcionales
        const aspectRatio = imageObj.naturalHeight / imageObj.naturalWidth;
        const finalWidth = baseWidth * initialScale;
        const finalHeight = finalWidth * aspectRatio;

        // Actualizar dimensiones y centrar
        konvaImage.width(finalWidth);
        konvaImage.height(finalHeight);
        konvaImage.x(initialPosition.x - finalWidth / 2);
        konvaImage.y(initialPosition.y - finalHeight / 2);

        this.layer.add(konvaImage);
        this.scheduleRedraw();
      };
      imageObj.src = src;

      return konvaImage;
    }

    private setupEventListeners() {
      // Usar un solo event listener para todos los eventos personalizados
      const eventHandler = (event: any) => {
        switch (event.type) {
          case "addHat":
            this.addHat(event.detail.src);
            break;
          case "addFace":
            this.addFace(event.detail.src);
            break;
          case "addOutfit":
            this.addOutfit(event.detail.src);
            break;
          case "clearElement":
            this.removeElement(event.detail.type);
            break;
          case "deleteSelected":
            this.deleteSelected();
            break;
        }
      };

      // Guardar referencia para poder limpiar más tarde
      this.eventHandler = eventHandler;

      // Agregar todos los event listeners de una vez
      this.eventTypes.forEach((eventType) => {
        window.addEventListener(eventType, eventHandler);
      });
    }

    public destroy() {
      if (this.eventHandler) {
        this.eventTypes.forEach((eventType) => {
          window.removeEventListener(eventType, this.eventHandler);
        });
      }
    }

    // Constantes para posiciones iniciales de imagenes (atuendos, ropa, etc.)
    private static readonly INITIAL_POSITIONS = {
      mobile: {
        hat: { x: 140, y: 85 },
        face: { x: 140, y: 150 },
        outfit: { x: 140, y: 255 },
      },
      desktop: {
        hat: { x: 200, y: 160 },
        face: { x: 200, y: 240 },
        outfit: { x: 200, y: 420 },
      },
    };

    private getPositions() {
      return this.isMobile
        ? GuaguaCanvas.INITIAL_POSITIONS.mobile
        : GuaguaCanvas.INITIAL_POSITIONS.desktop;
    }

    public addHat(src: string) {
      this.pendingVersions.hat += 1;
      const v = this.pendingVersions.hat;
      this.removeElement("hat");
      this.createDraggableImage(src, "hat", this.getPositions().hat, 1.0, v);
    }

    public addFace(src: string) {
      this.pendingVersions.face += 1;
      const v = this.pendingVersions.face;
      this.removeElement("face");
      this.createDraggableImage(src, "face", this.getPositions().face, 1.0, v);
    }

    public addOutfit(src: string) {
      this.pendingVersions.outfit += 1;
      const v = this.pendingVersions.outfit;
      this.removeElement("outfit");
      this.createDraggableImage(
        src,
        "outfit",
        this.getPositions().outfit,
        1.0,
        v
      );
    }

    public removeElement(type: string) {
      // Buscar y eliminar todos los elementos del tipo
      const elements = this.layer.find(`#${type}`);
      elements.forEach((element: any) => element.destroy());

      // Limpiar transformer si había elementos eliminados
      if (elements.length > 0) {
        this.removeTransformer();
        this.scheduleRedraw();
      }
    }

    public deleteSelected() {
      if (this.transformer) {
        const nodes = this.transformer.nodes();
        nodes.forEach((node: any) => {
          node.destroy();
        });
        this.removeTransformer();
        this.scheduleRedraw();
      }
    }

    public resize(width: number, height: number) {
      this.stage.width(width);
      this.stage.height(height);
      this.scheduleRedraw();
    }

    private addTransformer(node: any) {
      if (!this.transformer) {
        this.transformer = new Konva.Transformer({
          rotateEnabled: true,
          enabledAnchors: [
            "top-left",
            "top-right",
            "bottom-left",
            "bottom-right",
          ],
          padding: 8,
        });
        this.layer.add(this.transformer);
      }
      this.transformer.nodes([node]);
      this.transformer.moveToTop();
      this.scheduleRedraw();
    }

    private removeTransformer() {
      if (this.transformer) {
        this.transformer.nodes([]);
        this.scheduleRedraw();
      }
    }
  }

  // Configuración del tamaño del canvas
  const CANVAS_CONFIG = {
    mobile: {
      width: 280, // Ancho del canvas en móviles
      height: 500, // Alto del canvas en móviles
    },
    desktop: {
      width: 400, // Ancho del canvas en desktop
      height: 750, // Alto del canvas en desktop
    },
    breakpoint: 600, // Punto de quiebre para móvil/desktop en px
  };

  const updateResponsiveCanvasSize = (canvas: any) => {
    const container = document.getElementById("konva-container");
    if (!container) return;

    const isMobile = window.innerWidth < CANVAS_CONFIG.breakpoint;
    const config = isMobile ? CANVAS_CONFIG.mobile : CANVAS_CONFIG.desktop;

    // Calcular dimensiones máximas
    const vh = Math.max(
      document.documentElement.clientHeight || 0,
      window.innerHeight || 0
    );
    const vw = Math.max(
      document.documentElement.clientWidth || 0,
      window.innerWidth || 0
    );

    const maxHeight = Math.floor(0.8 * vh);
    const maxWidth = Math.floor(0.98 * vw);

    // Calcular dimensiones finales
    const width = Math.min(container.offsetWidth || vw, config.width, maxWidth);
    const height = Math.min(config.height, maxHeight);

    canvas.resize(width, height);
  };

  document.addEventListener("DOMContentLoaded", async () => {
    try {
      // Importar Konva dinámicamente
      const konvaModule = await import("konva");
      Konva = konvaModule.default;

      const canvas = new GuaguaCanvas("konva-stage");

      // Responsivo: ajustar tamaño al cargar y al cambiar tamaño
      updateResponsiveCanvasSize(canvas);
      window.addEventListener("resize", () =>
        updateResponsiveCanvasSize(canvas)
      );

      // Guardar referencia global para acceso desde otros scripts
      (window as any).guaguaCanvas = canvas;
    } catch (error) {
      console.error("Error loading Konva:", error);
    }
  });
</script>

<style>
  .konva-container {
    display: flex;
    justify-content: center;
    align-items: center;
    width: auto;
    height: auto;
    max-width: 100vw;
    max-height: 80vh;
    margin: 0 auto;
    box-sizing: border-box;
  }
  #konva-stage {
    display: block;
    margin: 0 auto;
    max-width: 100vw;
    max-height: 80vh;
    width: auto;
    height: auto;
  }
</style>
